<!DOCTYPE html>
<head>
  <title>Google Calendar Time Tacker</title>
  <base target="_top">
  <link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/add-ons.css">
  <style>
    @font-face {
      font-family: 'Ubuntu';
      src: url('data:font/ttf;base64,INLINE_FONT_UBUNTU_REGULAR') format('truetype');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Ubuntu';
      src: url('data:font/ttf;base64,INLINE_FONT_UBUNTU_BOLD') format('truetype');
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    table {
      border-collapse: collapse;
      border: var(--border-style);
      --border-style: .5px solid var(--gray-300);
      caption {
        font-size: 1rem;
        font-weight: bold;
        line-height: 2rem;
        text-align: start;
      }
      tr {
        border-top: var(--border-style);
        border-bottom: var(--border-style);
      }
      thead {
        font-weight: bold;
        background-color: lightgray;
      }
      th, td {
        border-left: var(--border-style);
        border-right: var(--border-style);
        padding: .25rem .5rem;
        border: .5px solid 
      }
      tr:nth-of-type(even) {
        background-color: var(--gray--tint);
      }
    }
    .cursor--hover-pointer:hover {
      cursor: pointer;
    }

    .date-picker {
      width: 15ch;
    }

    ul {
      list-style-type: none;
      margin-left: 0;
      padding-left: 0;
      li {
        input {
          width: 100%;
        }
        padding-bottom: .75rem;
      }
      :last-child {
        padding-bottom: 0;
      }
    }

    .submit-button {
      margin-top: .75rem;
    }

    .font-style-italic {
      font-style: italic;
    }

    .error-message {
      color: var(--error-red);
    }

    .progress-container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      width: 100%;
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      background: rgba(50, 50, 50, .85);
      color: var(--gray--tint);
    }

    .progress-spinner {
      border: 6px solid var(--gray--tint); /* Light grey border */
      border-top: 6px solid var(--info-blue); /* Blue border */
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .display-none {
      display: none;
    }

    body {
      --info-blue: #1967d2;
      --info-blue--tint: #e8f0fe;
      --error-red: #dd4b39;
      --gray--tint: #f3f3f3;
      --gray-300: #cccccc;
      font-family: Roboto,RobotoDraft,Helvetica,Arial,sans-serif
    }

    .info-circle {
      border: 2px solid var(--info-blue);
      /* background: #e8f0fe; */
      color: var(--info-blue);
      border-radius: 50%;
      width: 1rem;
      height: 1rem;
      text-align: center;
      cursor: default;
      font-weight: bold;
      font-size: 1rem;
      align-self: center;
    }

    .remember-calendar, .header-container {
      display: inline-flex;
      column-gap: .5rem;
      line-height: 1.25;
    }

    .invoice-remember-toggle {
      margin: .5rem 0 1rem;
    }

    #invoiceBuilderSection {
      margin-top: 2rem;
    }

    #invoiceBuilderFieldset[disabled] {
      opacity: 0.6;
    }

    #invoiceOutput {
      margin-top: 1.5rem;
      display: grid;
      row-gap: 1.5rem;
    }

    #invoiceOutput svg {
      width: 100%;
      max-width: 595px;
      border: 1px solid var(--gray-300);
      border-radius: 12.25px;
      background: white;
    }

    #invoiceDownloadButton,
    #invoiceDownloadSvgButton {
      margin-top: 1rem;
      width: fit-content;
    }

    #invoiceDownloadSvgButton {
      margin-left: .75rem;
    }

    #invoiceBuilderForm fieldset {
      border: 1px solid var(--gray-300);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
    }

    #invoiceBuilderForm fieldset legend {
      font-weight: 600;
      padding: 0 .25rem;
    }

    #invoiceBuilderForm textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: inherit;
      resize: vertical;
      min-height: 4rem;
    }

    #invoiceBuilderForm ul {
      display: grid;
      row-gap: .75rem;
    }

    #invoiceBuilderForm fieldset:last-of-type {
      margin-bottom: 0;
    }

    #invoiceBuilderForm label.required::after {
      content: ' *';
      color: var(--error-red);
      font-weight: bold;
    }

  </style>
</head>

<body>
  <main>
    <div class="header-container">
      <h1>
        Google Calendar Time Tracker
      </h1>
      <div title="Welcome to the Google Calendar Time Tracker!&#10;&#10; A quick and easy tool that calculates your time spent on events for any of your Google calendars.&#10;&#10;To track time for a Google calendar:&#10;&nbsp;&nbsp;&#8226; Create events for the calendar&#10;&nbsp;&nbsp;&#8226; Give events descriptive titles like &quot;Setting up time tracking&quot;&#10;&nbsp;&nbsp;&#8226; Use the Google Calendar Time Tracker weekly to get total and event-by-event hours" class="info-circle blue">i</div>
    </div>
    <form name="appForm" id="appForm">
      <fieldset>
        <legend></legend>
        <ul>
          <li>
            <label for="calendarSelect">Google calendar
              <span id="errorElement" class="error"></span>
            </label>
            <select name="calendars" id="calendarSelect" onchange="handleCalendarChange()" class="cursor--hover-pointer">
            </select>
          </li>
          <li>
            <label for="startDate">Start date (12:00 AM)</label>
            <input class="date-picker cursor--hover-pointer" type="date" id="startDate" name="startDate">
          </li>
          <li>
            <label for="endDate">End date (11:59 PM)</label>
            <input class="date-picker cursor--hover-pointer" type="date" id="endDate" name="endDate">
          </li>
          <li class="remember-calendar">
            <label for="rememberCalendarCheckbox">Remember calendar information</label>
            <input id="rememberCalendarCheckbox" type="checkbox" onchange="handleRememberCalendarChange(event)" class="cursor--hover-pointer"/>
            <div title="Save the calendar and date range to autofill next time" class="info-circle blue">i</div>
          </li>
        </ul>
      </fieldset>
    </form>
    <button class="submit-button action cursor--hover-pointer" onclick="onSubmit()">
      Get tracking summary and events
    </button>
    <section>
      <table id="summaryTable">
      </table>
      <table id="eventsTable">
      </table>
    </section>
    <section id="invoiceBuilderSection">
      <h2>Invoice Builder</h2>
      <div class="remember-calendar invoice-remember-toggle">
        <label for="rememberInvoiceInputsCheckbox">Remember invoice inputs</label>
        <input id="rememberInvoiceInputsCheckbox" type="checkbox" class="cursor--hover-pointer"/>
        <div title="Save all invoice fields and autofill them next time" class="info-circle blue">i</div>
      </div>
      <p id="invoiceBuilderStatusMessage">The Invoice Builder will be enabled after using the time tracker.</p>
      <fieldset id="invoiceBuilderFieldset" disabled>
        <form id="invoiceBuilderForm" onsubmit="handleInvoiceFormSubmit(event)">
          <fieldset>
            <legend>Invoice details</legend>
            <ul>
              <li>
                <label for="clientInvoiceNumberInput">Client-provided Invoice ID</label>
                <input id="clientInvoiceNumberInput" name="clientInvoiceNumber" type="text" autocomplete="off">
              </li>
              <li>
                <label class="required" for="invoiceNumberInput">Invoice ID</label>
                <input id="invoiceNumberInput" name="invoiceNumber" type="text" autocomplete="off" required>
              </li>
              <li>
                <label class="required" for="rateInput">Hourly rate</label>
                <input id="rateInput" name="rate" type="number" step="0.01" min="0" autocomplete="off" required>
              </li>
              <li>
                <label for="taxRateInput">Tax rate (%)</label>
                <input id="taxRateInput" name="taxRate" type="number" step="0.01" min="0" autocomplete="off">
              </li>
            </ul>
          </fieldset>
          <fieldset>
            <legend>My business</legend>
            <ul>
              <li>
                <label class="required" for="myBusinessNameInput">Business name</label>
                <input id="myBusinessNameInput" name="myBusinessName" type="text" autocomplete="organization" required>
              </li>
              <li>
                <label class="required" for="myBusinessEmailInput">Email</label>
                <input id="myBusinessEmailInput" name="myBusinessEmail" type="email" autocomplete="email" required>
              </li>
              <li>
                <label for="myBusinessPhoneInput">Phone number</label>
                <input id="myBusinessPhoneInput" name="myBusinessPhone" type="tel" autocomplete="tel">
              </li>
              <li>
                <label class="required" for="myBusinessAddressInput">Mailing address</label>
                <textarea id="myBusinessAddressInput" name="myBusinessAddress" autocomplete="street-address" required></textarea>
              </li>
              <li>
                <label for="howToPayInput">How to pay instructions</label>
                <textarea id="howToPayInput" name="howToPay" rows="3"></textarea>
              </li>
            </ul>
          </fieldset>
          <fieldset>
            <legend>Billed business</legend>
            <ul>
              <li>
                <label class="required" for="clientBusinessNameInput">Business name</label>
                <input id="clientBusinessNameInput" name="clientBusinessName" type="text" autocomplete="organization" required>
              </li>
              <li>
                <label class="required" for="clientBusinessAddressInput">Mailing address</label>
                <textarea id="clientBusinessAddressInput" name="clientBusinessAddress" autocomplete="street-address" required></textarea>
              </li>
              <li>
                <label for="clientBusinessPhoneInput">Phone number</label>
                <input id="clientBusinessPhoneInput" name="clientBusinessPhone" type="tel" autocomplete="tel">
              </li>
            </ul>
          </fieldset>
          <fieldset>
            <legend>Client contact</legend>
            <ul>
              <li>
                <label for="clientContactNameInput">Name</label>
                <input id="clientContactNameInput" name="clientContactName" type="text" autocomplete="name">
              </li>
              <li>
                <label for="clientContactEmailInput">Email</label>
                <input id="clientContactEmailInput" name="clientContactEmail" type="email" autocomplete="email">
              </li>
            </ul>
          </fieldset>
          <fieldset>
            <legend>Style</legend>
            <ul>
              <li>
                <label for="accentColorInput">Accent colour</label>
                <input id="accentColorInput" name="accentColor" type="color" value="#556B2F">
              </li>
            </ul>
          </fieldset>
          <button type="submit" class="submit-button cursor--hover-pointer">Generate invoice</button>
        </form>
      </fieldset>
      <div id="invoiceOutput"></div>
      <button id="invoiceDownloadButton" class="action cursor--hover-pointer display-none" onclick="handleInvoiceDownload(event)" disabled>
        Download PDF
      </button>
      <button id="invoiceDownloadSvgButton" class="action cursor--hover-pointer display-none" onclick="handleInvoiceSvgDownload(event)" disabled>
        Download SVG
      </button>
    </section>
    <div id="progressContainer" class="progress-container">
      <div class="progress-spinner"></div>
      <p id="progressText">Loading</p>
      <p id="progressAmount"></p>
    </div>
  </main>
  <!-- INLINE_JSPDF -->
  <!-- INLINE_SVG2PDF -->
  <script>
    class AppTable {
      constructor(tableElement, columns, data, caption) {
        // console.log(`#AppTable.constructor(tableElement, columns=${JSON.stringify(columns)}, data, caption)`);
        this.tableElement = tableElement;
        this.columns = columns;
        this.addHeaders(columns.map((col) => col.displayString));
        this.tableElement.createTBody();
        let tableCaption = this.tableElement.createCaption();
        tableCaption.textContent = caption;
        if(data) this.addRows(data);
        // TODO: show table only if setup succeeds
      }

      addHeaders(headerStrings) {
        const tHead = this.tableElement.createTHead();
        const row = tHead.insertRow();
        headerStrings.forEach((headerString) => {
          const cell = row.insertCell();
          cell.innerText = (headerString);
          cell.scope = "col";
        });
      }

      addRows(rowsData) {
        rowsData.forEach((rowData) => this.addRow(rowData));
      }

      addRow(rowData) {
        const tBody = this.tableElement.tBodies[0];
        const row = tBody.insertRow();
        this.columns.forEach((appCol) => {
          const cell = row.insertCell();
          cell.innerText = appCol.transform(rowData) ?? "Missing data";
        });
      }
    }

    class DateTimeUtils {
      constructor() {}

      getFormatedDateTime(date) {
        const dateFormatOptions = {
          weekday: 'long',
          month: 'short',
          day: 'numeric',
        };

        return `${date.toLocaleDateString('en-US', dateFormatOptions)}, ${this.getFormatedTime(date)}`
      };

      getFormatedTime(date) {
        const timeFormatOptions = {
          timeStyle: 'short',
        }
        return `${date.toLocaleTimeString('en-US', timeFormatOptions)}`
      }

      getNumHoursInRange(start, end) {
        const span = end - start;
        return span / (1000 * 60 * 60);
      }

      getNumDaysFromHours(hours) {
        return Math.round(hours / 24);
      }

      getNumDaysInRange(start, end) {
        return this.getNumDaysFromHours(getNumHoursInRange(start, end));
      }

      hoursToMs(hours) {
        return hours * 60 * 60 * 1000;
      }
    }

    google.script.run
      .withSuccessHandler(function(token) {
        if(token == 'Access Denied') {
          alert("You do not have the necessary Google permissions.");
        } else {
          _accessToken = token;
          onAuthSuccess();
        }
      })
      .withFailureHandler(function(error) {
        onSuccess(error);
        console.error(`#google.script.run.getOAuthToken()
        Error: ${JSON.stringify(error)}`);
      })
      .client_getOAuthToken();

    let _accessToken = null;
    let _calendarOptions;
    const LOCAL_STORAGE_APP_PREFIX = 'gctt_';
    const CALENDAR_STORAGE_KEY = `${LOCAL_STORAGE_APP_PREFIX}calendarInfo`;
    const INVOICE_DETAILS_STORAGE_KEY = `${LOCAL_STORAGE_APP_PREFIX}invoiceDetails`;
    
    let _activeErrorMessageElements = [];
    const _progressAmountElement = document.getElementById('progressAmount');
    const _progressTextElement = document.getElementById('progressText');
    const _progressContainerElement = document.getElementById('progressContainer');
    const _progressSpinnerElement = document.getElementById('progressSpinner');
    const _form = document.getElementById('appForm')
    const _startDateInput = document.getElementById('startDate');
    const _endDateInput = document.getElementById('endDate');
    [_startDateInput, _endDateInput].forEach((element) => {
      if(element) {
        element.addEventListener('change', handleCalendarDateInputChange);
      }
    });

    const DEFAULT_ACCENT_COLOR = '#556B2F';
    const MAX_ROWS_PER_TOTALS_PAGE = 16;
    const MAX_ROWS_PER_STANDARD_PAGE = 25;
    const INVOICE_DESCRIPTION_MAX_WIDTH = 201;
    const INVOICE_DUE_DATE_OFFSET_DAYS = 14;
    const ROW_BASELINE_START_Y = 347.636;
    const ROW_VERTICAL_SPACING = 17;
    const ROW_MULTILINE_LINE_HEIGHT = 12;
    const DARK_ROW_RECT_VERTICAL_OFFSET = 10.636;
    const ROW_RIGHT_BOUNDARY_X = 563;
    const ROW_RIGHT_PADDING = 4;
    const SUMMARY_RIGHT_BOUNDARY_X = 563;
    const SUMMARY_RIGHT_PADDING = 6;
    const DEFAULT_PDF_FONT = 'Ubuntu';
    const FONT_UBUNTU_REGULAR_BASE64 = 'INLINE_FONT_UBUNTU_REGULAR';
    const FONT_UBUNTU_BOLD_BASE64 = 'INLINE_FONT_UBUNTU_BOLD';
    // Manual right-alignment X adjustments for specific invoice fields.
    const RIGHT_ALIGNMENT_X_OFFSET_OVERRIDES = [
      { idFragment: 'amountvalue', offset: 23 },
      { idFragment: 'ratevalue', offset: 22 },
      { idFragment: 'invoiceofvalue', offset: 85 },
      { idFragment: 'totalhoursvalue', offset: 23 },
      { idFragment: 'subtotalvalue', offset: 23 },
      { idFragment: 'totalvalue', offset: 23 },
      { idFragment: 'taxvalue', offset: 10 },
    ];
    const RIGHT_ALIGNED_IDS = [
      'amountvalue',
      'ratevalue',
      'invoiceofvalue',
      'totalhoursvalue',
      'subtotalvalue',
      'totalvalue',
      'taxvalue',
    ];
    let _invoiceBuilderController = null;

    const _dtu_dateTimeUtils = new DateTimeUtils();
    function appPostMessage(message) {
      try {
        window.parent.parent.parent.postMessage(message, '*');
      } catch (error) {
        console.warn(`window.parent.parent.parent.postMessage(message=${message}) failed. This might be because: 1. the Google changed the number of window parents, or 2. This is not running in an iFrame.`);
      }
    }
    // This may be running in an iFrame. Send a message out of the iFrame so the container knows the user is logged in, otherwise we wouldn't have made it this far
    appPostMessage('success');

    // If it is in an iFrame, the container cannot register for events within the iFrame so let it know there was a click event
    // For example, this is used by ncbrewer.ca to inform it that there was a click outside of the mobile navigation menu so the menu will close
    document.addEventListener('click', (event) => appPostMessage('click event'));

    // TODO: finish
    function setupRememberDates() {
      setupStorageCheckbox('local', 'rememberDates');
    }

    function computeIsKeyInLocalStorage(key) {
      if(!key || key.length === 0) {
        throw new Error(`#isKeyInLocalStorage(key=${key})
        Missing required param error. Param 'key' is required`);
      }
      return !!window.localStorage.getItem(key);
    }

    function getStoredCalendarInfo() {
      const stored = window.localStorage.getItem(CALENDAR_STORAGE_KEY);
      if(stored) {
        try {
          const parsed = JSON.parse(stored);
          if(parsed && typeof parsed === 'object') {
            return {
              calendarId: typeof parsed.calendarId === 'string' ? parsed.calendarId : '',
              startDate: typeof parsed.startDate === 'string' ? parsed.startDate : '',
              endDate: typeof parsed.endDate === 'string' ? parsed.endDate : '',
            };
          }
        } catch (error) {
          console.warn('#getStoredCalendarInfo() unable to parse stored calendar info. Clearing.', error);
          window.localStorage.removeItem(CALENDAR_STORAGE_KEY);
        }
      }
      const legacyCalendarId = window.localStorage.getItem(`${LOCAL_STORAGE_APP_PREFIX}appCalendarData`);
      if(typeof legacyCalendarId === 'string' && legacyCalendarId.length > 0) {
        return {
          calendarId: legacyCalendarId,
          startDate: '',
          endDate: '',
        };
      }
      return null;
    }

    function writeCalendarInfoToStorage(info) {
      if(!info || typeof info.calendarId !== 'string' || info.calendarId.length === 0) {
        return;
      }
      const payload = {
        calendarId: info.calendarId,
        startDate: typeof info.startDate === 'string' ? info.startDate : '',
        endDate: typeof info.endDate === 'string' ? info.endDate : '',
      };
      window.localStorage.setItem(CALENDAR_STORAGE_KEY, JSON.stringify(payload));
      window.localStorage.removeItem(`${LOCAL_STORAGE_APP_PREFIX}appCalendarData`);
    }

    function clearStoredCalendarInfo() {
      window.localStorage.removeItem(CALENDAR_STORAGE_KEY);
      window.localStorage.removeItem(`${LOCAL_STORAGE_APP_PREFIX}appCalendarData`);
    }

    function computeIsCalendarInLocalStorage() {
      return !!getStoredCalendarInfo();
    }

    function setupRememberCalendar() {
      const storedInfo = getStoredCalendarInfo();
      const isRemembering = !!(storedInfo && typeof storedInfo.calendarId === 'string' && storedInfo.calendarId.length > 0);
      setIsCheckedForElementWithId('rememberCalendarCheckbox', isRemembering);
      if(!storedInfo) {
        return;
      }
      if(_calendarOptions && storedInfo.calendarId && _calendarOptions.computeHasCalendar(storedInfo.calendarId)) {
        _calendarOptions.setValue(storedInfo.calendarId);
      }
      const startDateElement = document.getElementById('startDate');
      const endDateElement = document.getElementById('endDate');
      const todayString = new Date(Date.now()).toISOString().split('T')[0];
      if(startDateElement && typeof storedInfo.startDate === 'string' && storedInfo.startDate.length > 0) {
        startDateElement.value = storedInfo.startDate > todayString ? todayString : storedInfo.startDate;
      }
      if(endDateElement && typeof storedInfo.endDate === 'string' && storedInfo.endDate.length > 0) {
        endDateElement.value = storedInfo.endDate > todayString ? todayString : storedInfo.endDate;
      }
      if(isRemembering) {
        writeCalendarInfoToStorage({
          calendarId: storedInfo.calendarId,
          startDate: startDateElement?.value ?? '',
          endDate: endDateElement?.value ?? '',
        });
      }
    }
    // TODO: Finish
    // function setupStorageCheckbox(typeOfStorage, key) {
    //   console.log(`setupStorageCheckbox(typeOfStorage=${typeOfStorage}, key=${key})`);
    //   if(computeIsKeyInStorage(typeOfStorage, key)) {
    //     setIsCheckedForElementWithId(key, true);
    //   }
    // }

    function setIsCheckedForElementWithId(id, checked) {
      if(!id || id.length === 0) {
        throw new Error(`#setIsCheckedForElementWithId(id=${id})
        Missing required param error. Param 'id' is required`);
      }
      const element = document.getElementById(id);
      if(!element) {
        throw new Error(`#setIsCheckedForElementWithId(id=${id})
        Element not found error. Element with \`id\` not found`);
      }
      return element.checked = checked;
    }

    function handleCalendarChange() {
      if(getCheckedForElementWithId('rememberCalendarCheckbox')) {
        updateCalendarInfoStorage();
      }
    }

    function updateCalendarInfoStorage() {
      if(!_calendarOptions) {
        return;
      }
      if(!getCheckedForElementWithId('rememberCalendarCheckbox')) {
        return;
      }
      const info = {
        calendarId: _calendarOptions.getSelectElementValue(),
        startDate: _form?.startDate?.value ?? '',
        endDate: _form?.endDate?.value ?? '',
      };
      writeCalendarInfoToStorage(info);
    }

    function handleCalendarDateInputChange() {
      if(!getCheckedForElementWithId('rememberCalendarCheckbox')) {
        return;
      }
      updateCalendarInfoStorage();
    }

    function getCheckedForElementWithId(id) {
      if(!id || id.length === 0) {
        throw new Error(`#getCheckedForElementWithId(id=${id})
        Missing required param error. Param 'id' is required`);
      }
      const element = document.getElementById(id)
      if(!element) {
        throw new Error(`#getCheckedForElementWithId(id=${id})
        Element not found error. Element with \`id\` not found`);
      }
      return element.checked;
    }

    function handleRememberCalendarChange(event) {
      const isChecked = event?.target?.checked ?? getCheckedForElementWithId('rememberCalendarCheckbox');
      if(isChecked) {
        updateCalendarInfoStorage();
      } else {
        clearStoredCalendarInfo();
      }
    }

    function handleInvoiceFormSubmit(event) {
      event.preventDefault();
      if(_invoiceBuilderController) {
        _invoiceBuilderController.handleFormSubmit(event);
      }
    }

    function handleInvoiceDownload(event) {
      event.preventDefault();
      if(_invoiceBuilderController) {
        _invoiceBuilderController.handleDownloadClick(event);
      }
    }

    function handleInvoiceSvgDownload(event) {
      event.preventDefault();
      if(_invoiceBuilderController) {
        _invoiceBuilderController.handleSvgDownloadClick(event);
      }
    }

    function onAuthSuccess() {
      google.script.run
      .withSuccessHandler(async function(data) {
        setup(data);
        hideElement(_progressContainerElement);
      })
      .withFailureHandler(function(error) {
        hideElement(_progressContainerElement);
        resetProgressContainerChildren();
        presentError(error);
        const message = `Error setting up.
        ${error.message}`;
        onSuccess(error.message);
        console.error(`#google.script.run.getSetupData()
        error${JSON.stringify(error)}
        `);
      })
      .client_getSetupData();
    }

    function resetProgressContainerChildren() {
      setProgressText('Uploading');
      setProgressAmount(0);
      showElement(_progressAmountElement);
      showElement(_progressTextElement);
      showElement(_progressSpinnerElement);
    }

    function hideElement(element) {
      if(element) {
        element.classList.add('display-none');
      }
    }

    function setProgressText(text) {
      _progressTextElement.innerText = text;
    }

    function setProgressAmount(number) {
      _progressAmountElement.innerText =`${number}%`;
    }

    function showElement(element) {
      if(element && element.classList.contains('display-none')) {
        element.classList.remove('display-none');
      }
    }

    function setup(data) {
      if(!data.calendars) {
        console.error(`#setup(data=${JSON.stringify(data)})
        Error. calendars data is required for setup
        `);
        return;
      }
      _calendarOptions = new CalendarOptions(data.calendars);
      setupDatePickers();
      setupRememberCalendar();
      // setupRememberDates()
    }

    function setupDatePickers() {
      const startDateElement = document.getElementById('startDate');
      const endDateElement = document.getElementById('endDate');
      const todayString = new Date(Date.now()).toISOString().split('T')[0];
      [startDateElement, endDateElement].forEach((element) => {
        if(!element) {
          return;
        }
        element.max = todayString;
        if(!element.value) {
          element.value = todayString;
        }
      });
    }

    function onSubmit() {
      validateForm();
      if(computeIsFormValid()) {
        showElement(_progressSpinnerElement);
        showElement(_progressContainerElement);
        setProgressText('Working');
        if(computeIsEventsTablePopulated()) {
          clearTables();
        }
        run()
      }

    }

    function computeIsEventsTablePopulated() {
      return document.getElementById('eventsTable')?.rows.length > 0
    }

    function validateForm() {
      // TODO: vailidation: Make sure that the `end date` is larger than the `start date`
      _activeErrorMessageElements.forEach((errorElement) => {
        errorElement.innerText = '';
      });
      _activeErrorMessageElements = [];
      // TODO: Validate form. If there are errors, get their elements (make sure their `innerText` attributes are set correctly) and push them into the arr
      const startDate = new Date(_form.startDate.value)
      const endDate = new Date(_form.endDate.value)
      if(endDate < startDate) {
        // TODO: handle error
      }
    }

    function computeIsFormValid() {
      return _activeErrorMessageElements.length === 0;
    }

    function clearTables() {
      [document.getElementById('summaryTable'), document.getElementById('eventsTable')].forEach((table) => {
        table.deleteTHead();
        table.deleteCaption();
        [...table.tBodies].forEach((tBody) => {
          tBody.remove();
        })
      });
    }

    function setupTables(summaryTableData, eventsData) {
      const summaryTableColumns = [
        {displayString: 'Calendar', transform: (rowData) => rowData.calendarName },
        {displayString: 'Start date', transform: (rowData) => _dtu_dateTimeUtils.getFormatedDateTime(new Date(rowData.start))},
        {displayString: 'End date', transform: (rowData) => _dtu_dateTimeUtils.getFormatedDateTime(new Date(rowData.end))},
        {displayString: 'Number of events', transform: (rowData) => rowData.numEvents},
        {displayString: 'Total hours', transform: (rowData) => rowData.totalHours}
      ];
      const eventsTableColumns = [
        {displayString: 'Title', transform: (rowData) => rowData.title},
        {displayString: 'Start time', transform: (rowData) => _dtu_dateTimeUtils.getFormatedDateTime(new Date(rowData.start))},
        {displayString: 'End time', transform: (rowData) => _dtu_dateTimeUtils.getFormatedDateTime(new Date(rowData.end))},
        {displayString: 'Hours', transform: (rowData) => rowData.hours},
      ];

      const summaryTableElement = document.getElementById('summaryTable');
      const eventsTableElement = document.getElementById('eventsTable');
      const summaryTable = new AppTable(summaryTableElement, summaryTableColumns, [summaryTableData], 'Calendar summary');
      const eventsTable = new AppTable(eventsTableElement, eventsTableColumns, eventsData, 'Calendar details');
    }

    function setupTable(id, dataForTable) {
      const tableElement = document.getElementById(id);
      if(!tableElement) {
        console.error(`#setupTable(id=${id})
          Table not found error.
        `);
        return;
      }
      console.log('tableElement', tableElement)
      const headers = getTableHeaders(tableElement);
      const tBody = tableElement.tBodies[0];
      dataForTable.forEach((data) => {
        const row = tBody.insertRow();
        headers.forEach((header) => {
          row.insertCell().textContent = data[header.toLowerCase] ?? 'Missing data'});
      });
    }

    class AppColumn {
      constructor(displayString, transform) {
        this.displayString = displayString;
        this.transform = transform;
      }
    }

    function getTableHeaders(tableElement) {
      const headers = []
      const cells = tableElement.tHead?.rows[0].cells;
      if(!cells) {
        console.error(`#getTableHeaders(tableElement=${JSON.stringify(tableElement)})
          Error. Param does not have tHead element.
        `);
        return null;
      }
      for(const thElement of cells) {
        headers.push(thElement.innerText);
      }
      return headers;
    }

    async function run() {
      try {
        google.script.run
          .withSuccessHandler(function(resultsData) {
            if(!resultsData) {
              throw new Error(`#Error in google.script.run |> successHandler(resultsData=${resultsData})
              Parameter missing error. resultsData is requried
              `);
            }
            setupTables(resultsData.summaryData, resultsData.eventsData);
            if(_invoiceBuilderController) {
              _invoiceBuilderController.onResults(resultsData);
            }
            hideElement(_progressContainerElement);
          })
          .withFailureHandler(function(error) {
            hideElement(_progressContainerElement);
            resetProgressContainerChildren();
            presentError(error);
            const message = `Error setting up.
            ${error.message}`;
            onSuccess(error.message);
            console.error(`#google.script.run.client_computeResults()
              error${JSON.stringify(error)}`
            );
          })
          .client_computeResults(
            _form.calendars.value,
            {
              // use `replace` to get to yyyy/mm/dd format so there is no UTC converstion before setting hours
              start: new Date(_form.startDate.value.replace('-', '/')).setHours(0, 0, 1),
              end: new Date(_form.endDate.value.replace('-', '/')).setHours(23, 59, 59)
            }
          );
      } catch (error) {
        const message = `#run()
        Error: ${error.message}`;
        console.error(`#run()
        Error: ${JSON.stringify(error)}`);
        onFailure(message);
      }
    }

    function onSuccess() {
      hideElement(_progressSpinnerElement);
      hideElement(_progressAmountElement);
      setProgressText('Success');
    }

    function presentError(message) {
      alert(message + "\n" + " Please try again. If the error persists, please contact the developer nathanielc.brewer@gmail.com");
    }

    function onFailure(errorMessage) {
      hideElement(_progressContainerElement);
      resetProgressContainerChildren();
      presentError(errorMessage);
    }

    class CalendarOptions {
      constructor(calendars, config) {
        console.log('CalendarOptions', calendars)
        this.config = config;
        this.calendars = calendars;
        this.currentCalendar = undefined;
        this.calendarSelectElement = document.getElementById('calendarSelect');
        calendars
          .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()))
          .forEach((calendar, index) => {
            this.calendarSelectElement.add(new Option(calendar.name, calendar.id, (index === 0)));
          })
      }

      getSelectElementValue() {
        return this.calendarSelectElement.value;
      }

      computeHasCalendar(id) {
        return this.calendars.some((calendar) => (id === calendar.id)) || false;
      }

      setValue(id) {
        this.calendarSelectElement.value = id;
      }
    }

    function formatCurrency(amount) {
      const numericAmount = Number.isFinite(amount) ? amount : 0;
      return `$${numericAmount.toFixed(2)}`;
    }

    function formatInvoiceHeaderDate(date) {
      const workingDate = new Date(date.getTime());
      const day = workingDate.getDate();
      const month = workingDate.toLocaleDateString('en-US', { month: 'short' });
      const year = workingDate.getFullYear();
      return `${day} ${month}, ${year}`;
    }

    function formatInvoiceRowDate(date) {
      return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
    }

    function formatInvoiceRowTime(date) {
      return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
    }

    function addDays(date, numberOfDays) {
      const workingDate = new Date(date.getTime());
      workingDate.setDate(workingDate.getDate() + numberOfDays);
      return workingDate;
    }

    function roundToTwo(value) {
      const numericValue = Number(value) || 0;
      return Math.round(numericValue * 100) / 100;
    }

    function formatHours(value) {
      const rounded = roundToTwo(value);
      return rounded.toFixed(2).replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
    }

    function normalizeSingleLineText(value) {
      if(value == null) {
        return '';
      }
      const stringValue = value.toString().replace(/\r\n/g, '\n');
      return stringValue
        .split('\n')
        .map((line) => line.trim())
        .filter((line) => line.length > 0)
        .join(' ')
        .trim();
    }

    function normalizeMultilineText(value) {
      if(value == null) {
        return '';
      }
      const normalized = value.toString().replace(/\r\n/g, '\n');
      const lines = normalized.split('\n').map((line) => line.replace(/\s+$/g, ''));
      while(lines.length > 0 && lines[0].trim().length === 0) {
        lines.shift();
      }
      while(lines.length > 0 && lines[lines.length - 1].trim().length === 0) {
        lines.pop();
      }
      return lines.join('\n').trim();
    }

    function isValidEmail(value) {
      if(!value) {
        return false;
      }
      const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return EMAIL_REGEX.test(value);
    }

    function isValidHexColor(value) {
      if(typeof value !== 'string') {
        return false;
      }
      return /^#([0-9a-fA-F]{6})$/.test(value.trim());
    }

    function parseHexColor(value) {
      if(!isValidHexColor(value)) {
        return null;
      }
      const hex = value.replace('#', '');
      return {
        r: parseInt(hex.slice(0, 2), 16),
        g: parseInt(hex.slice(2, 4), 16),
        b: parseInt(hex.slice(4, 6), 16),
      };
    }

    function formatRgbToHex(r, g, b) {
      const clamp = (component) => Math.max(0, Math.min(255, Math.round(component)));
      const toHex = (component) => clamp(component).toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function buildMultilineValue(lines) {
      if(!Array.isArray(lines)) {
        return '';
      }
      return lines
        .flatMap((entry) => {
          if(entry == null) {
            return [];
          }
          const normalized = entry.toString().replace(/\r\n/g, '\n');
          return normalized.split('\n');
        })
        .map((part) => part.trim())
        .filter((part) => part.length > 0)
        .join('\n');
    }

    function formatPercentage(value) {
      if(!Number.isFinite(value) || value === 0) {
        return '';
      }
      const fixed = Math.abs(value % 1) < 0.01 ? value.toFixed(0) : value.toFixed(2);
      return `${fixed.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1')}%`;
    }

    class InvoiceBuilderController {
      constructor() {
        this.fieldset = document.getElementById('invoiceBuilderFieldset');
        this.statusMessageElement = document.getElementById('invoiceBuilderStatusMessage');
        this.outputElement = document.getElementById('invoiceOutput');
        this.downloadButton = document.getElementById('invoiceDownloadButton');
        this.downloadSvgButton = document.getElementById('invoiceDownloadSvgButton');
        this.templates = null;
        this.templatePromise = null;
        this.resultsData = null;
        this.measureCanvas = document.createElement('canvas');
        this.measureContext = this.measureCanvas?.getContext('2d') ?? null;
        this.canvasFont = '600 10px "Inter", sans-serif';
        this.lastInvoiceMetadata = null;
        this.form = document.getElementById('invoiceBuilderForm');
        this.rememberInvoiceCheckbox = document.getElementById('rememberInvoiceInputsCheckbox');
        this.invoiceDetailsStorageKey = INVOICE_DETAILS_STORAGE_KEY;
        this.isApplyingStoredInvoice = false;
        this.initInvoiceDetailsPersistence();
        this.disable('The Invoice Builder will be enabled after using the time tracker.');
      }

      initInvoiceDetailsPersistence() {
        if(this.rememberInvoiceCheckbox) {
          this.rememberInvoiceCheckbox.addEventListener('change', () => this.handleInvoiceRememberChange());
        }
        if(this.form) {
          const persistHandler = () => this.handleInvoiceFormInput();
          this.form.addEventListener('input', persistHandler);
          this.form.addEventListener('change', persistHandler);
        }
        this.applyStoredInvoiceDetails();
      }

      handleInvoiceRememberChange() {
        if(!this.rememberInvoiceCheckbox) {
          return;
        }
        if(this.rememberInvoiceCheckbox.checked) {
          this.persistInvoiceDetailsIfNeeded();
        } else {
          window.localStorage.removeItem(this.invoiceDetailsStorageKey);
        }
      }

      handleInvoiceFormInput() {
        this.persistInvoiceDetailsIfNeeded();
      }

      persistInvoiceDetailsIfNeeded() {
        if(this.isApplyingStoredInvoice) {
          return;
        }
        if(!this.rememberInvoiceCheckbox || !this.rememberInvoiceCheckbox.checked) {
          return;
        }
        const values = this.collectInvoiceFormValues();
        if(!values) {
          return;
        }
        const payload = {
          checked: true,
          values,
        };
        try {
          window.localStorage.setItem(this.invoiceDetailsStorageKey, JSON.stringify(payload));
        } catch (error) {
          console.warn('#InvoiceBuilderController.persistInvoiceDetailsIfNeeded() failed', error);
        }
      }

      collectInvoiceFormValues() {
        if(!this.form) {
          return null;
        }
        const formData = new FormData(this.form);
        const toSingle = (name) => normalizeSingleLineText(formData.get(name));
        const toMulti = (name) => normalizeMultilineText(formData.get(name));
        const numericToString = (name) => (formData.get(name) ?? '').toString().trim();
        const accentValueRaw = (formData.get('accentColor') ?? DEFAULT_ACCENT_COLOR).toString().trim();
        return {
          invoiceNumber: toSingle('invoiceNumber'),
          clientInvoiceNumber: toSingle('clientInvoiceNumber'),
          rate: numericToString('rate'),
          taxRate: numericToString('taxRate'),
          myBusinessName: toSingle('myBusinessName'),
          myBusinessEmail: toSingle('myBusinessEmail'),
          myBusinessPhone: toSingle('myBusinessPhone'),
          myBusinessAddress: toMulti('myBusinessAddress'),
          howToPay: toMulti('howToPay'),
          clientBusinessName: toSingle('clientBusinessName'),
          clientBusinessAddress: toMulti('clientBusinessAddress'),
          clientBusinessPhone: toSingle('clientBusinessPhone'),
          clientContactName: toSingle('clientContactName'),
          clientContactEmail: toSingle('clientContactEmail'),
          accentColor: isValidHexColor(accentValueRaw) ? accentValueRaw : DEFAULT_ACCENT_COLOR,
        };
      }

      applyStoredInvoiceDetails() {
        if(!this.form) {
          return;
        }
        const raw = window.localStorage.getItem(this.invoiceDetailsStorageKey);
        if(!raw) {
          if(this.rememberInvoiceCheckbox) {
            this.rememberInvoiceCheckbox.checked = false;
          }
          return;
        }
        let payload;
        try {
          payload = JSON.parse(raw);
        } catch (error) {
          console.warn('#InvoiceBuilderController.applyStoredInvoiceDetails() unable to parse stored data. Clearing.', error);
          window.localStorage.removeItem(this.invoiceDetailsStorageKey);
          if(this.rememberInvoiceCheckbox) {
            this.rememberInvoiceCheckbox.checked = false;
          }
          return;
        }
        const values = payload?.values && typeof payload.values === 'object' ? payload.values : payload;
        const isChecked = payload?.checked !== false;
        if(this.rememberInvoiceCheckbox) {
          this.rememberInvoiceCheckbox.checked = isChecked;
        }
        if(!values || typeof values !== 'object') {
          return;
        }
        const assignValue = (name, nextValue) => {
          const element = this.form?.elements?.namedItem(name);
          if(element && typeof element.value !== 'undefined') {
            element.value = nextValue ?? '';
          }
        };
        this.isApplyingStoredInvoice = true;
        assignValue('invoiceNumber', values.invoiceNumber ?? '');
        assignValue('clientInvoiceNumber', values.clientInvoiceNumber ?? '');
        assignValue('rate', values.rate ?? '');
        assignValue('taxRate', values.taxRate ?? '');
        assignValue('myBusinessName', values.myBusinessName ?? '');
        assignValue('myBusinessEmail', values.myBusinessEmail ?? '');
        assignValue('myBusinessPhone', values.myBusinessPhone ?? '');
        assignValue('myBusinessAddress', values.myBusinessAddress ?? '');
        assignValue('howToPay', values.howToPay ?? '');
        assignValue('clientBusinessName', values.clientBusinessName ?? '');
        assignValue('clientBusinessAddress', values.clientBusinessAddress ?? '');
        assignValue('clientBusinessPhone', values.clientBusinessPhone ?? '');
        assignValue('clientContactName', values.clientContactName ?? '');
        assignValue('clientContactEmail', values.clientContactEmail ?? '');
        const accentColorElement = this.form?.elements?.namedItem('accentColor');
        if(accentColorElement && typeof accentColorElement.value !== 'undefined') {
          const accentValue = isValidHexColor(values.accentColor)
            ? values.accentColor
            : DEFAULT_ACCENT_COLOR;
          accentColorElement.value = accentValue;
        }
        this.isApplyingStoredInvoice = false;
        this.persistInvoiceDetailsIfNeeded();
      }

      disable(message) {
        if(this.fieldset) {
          this.fieldset.disabled = true;
        }
        if(this.statusMessageElement && typeof message === 'string') {
          this.statusMessageElement.textContent = message;
        }
        this.clearOutput();
        this.setDownloadButtonState(false);
      }

      clearOutput() {
        if(this.outputElement) {
          this.outputElement.innerHTML = '';
        }
        this.lastInvoiceMetadata = null;
        this.setDownloadButtonState(false);
      }

      onResults(resultsData) {
        const hasRows = resultsData?.eventsData && Array.isArray(resultsData.eventsData) && resultsData.eventsData.length > 0;
        if(!hasRows) {
          this.resultsData = null;
          this.disable('Run the time tracker for a period with events to enable the Invoice Builder.');
          return;
        }
        this.resultsData = {
          summaryData: resultsData.summaryData,
          eventsData: resultsData.eventsData.slice(),
        };
        if(this.fieldset) {
          this.fieldset.disabled = false;
        }
        if(this.statusMessageElement) {
          this.statusMessageElement.textContent = 'Invoice Builder is ready. Update the fields and generate the invoice.';
        }
        this.clearOutput();
      }

      async handleFormSubmit(event) {
        event.preventDefault();
        if(!this.resultsData || !Array.isArray(this.resultsData.eventsData) || this.resultsData.eventsData.length === 0) {
          return;
        }
        const form = event.target;
        if(form instanceof HTMLFormElement && !form.reportValidity()) {
          return;
        }
        const formData = new FormData(form);
        const parsed = this.parseInvoiceForm(formData);
        if(parsed.errors.length > 0) {
          this.presentInvoiceErrors(parsed.errors);
          return;
        }
        const {
          invoiceNumber,
          clientInvoiceNumber,
          hourlyRate,
          taxRatePercent,
          myBusiness,
          clientBusiness,
          clientContact,
          howToPay,
          accentColor,
        } = parsed.data;
        try {
          const templates = await this.loadTemplates();
          const invoiceDate = new Date();
          const dueDate = addDays(invoiceDate, INVOICE_DUE_DATE_OFFSET_DAYS);
          const rows = this.prepareRows(hourlyRate);
          const subtotalCents = rows.reduce((sum, row) => sum + row.amountCents, 0);
          const taxCents = Math.round(subtotalCents * (taxRatePercent / 100));
          const totalCents = subtotalCents + taxCents;
          const subtotalText = formatCurrency(subtotalCents / 100);
          const totalText = formatCurrency(totalCents / 100);
          const taxAmount = taxCents / 100;
          const taxPercentageText = formatPercentage(taxRatePercent);
          const taxText = taxPercentageText
            ? `${formatCurrency(taxAmount)} (${taxPercentageText})`
            : formatCurrency(taxAmount);
          const summaryTotalHours = Number(this.resultsData?.summaryData?.totalHours);
          let totalHoursValue = Number.isFinite(summaryTotalHours) ? summaryTotalHours : NaN;
          if(!Number.isFinite(totalHoursValue)) {
            totalHoursValue = (this.resultsData?.eventsData || []).reduce((sum, event) => {
              const hours = Number(event?.hours);
              return sum + (Number.isFinite(hours) ? hours : 0);
            }, 0);
          }
          if(!Number.isFinite(totalHoursValue)) {
            totalHoursValue = 0;
          }
          const totalHoursString = formatHours(totalHoursValue);
          const pages = this.buildPages({
            rows,
            templates,
            invoiceNumber,
            clientInvoiceNumber,
            invoiceDate,
            dueDate,
            subtotalText,
            taxText,
            totalText,
            totalHoursString,
            myBusiness,
            clientBusiness,
            clientContact,
            howToPay,
            accentColor,
          });
          this.lastInvoiceMetadata = {
            invoiceNumber,
            clientInvoiceNumber,
            invoiceDate,
            myBusinessName: myBusiness.name,
            accentColor,
          };
          this.renderPages(pages);
          this.persistInvoiceDetailsIfNeeded();
        } catch (error) {
          console.error('#InvoiceBuilderController.handleFormSubmit()', error);
          presentError('Unable to generate the invoice. Please try again.');
        }
      }

      parseInvoiceForm(formData) {
        const errors = [];
        const invoiceNumber = normalizeSingleLineText(formData.get('invoiceNumber'));
        if(!invoiceNumber) {
          errors.push('Invoice number is required.');
        }
        const clientInvoiceNumber = normalizeSingleLineText(formData.get('clientInvoiceNumber'));
        const rateRaw = (formData.get('rate') ?? '').toString().trim();
        let hourlyRate = Number.NaN;
        if(rateRaw.length === 0) {
          errors.push('Hourly rate is required.');
        } else {
          hourlyRate = Number.parseFloat(rateRaw);
          if(!Number.isFinite(hourlyRate) || hourlyRate < 0) {
            errors.push('Hourly rate must be zero or a positive number.');
          }
        }
        const taxRateRaw = (formData.get('taxRate') ?? '').toString().trim();
        let taxRatePercent = 0;
        if(taxRateRaw.length > 0) {
          const parsedTaxRate = Number.parseFloat(taxRateRaw);
          if(Number.isFinite(parsedTaxRate) && parsedTaxRate >= 0) {
            taxRatePercent = parsedTaxRate;
          } else {
            errors.push('Tax rate must be zero or a positive number.');
          }
        }
        const myBusinessName = normalizeSingleLineText(formData.get('myBusinessName'));
        if(!myBusinessName) {
          errors.push('My business name is required.');
        }
        const myBusinessEmail = normalizeSingleLineText(formData.get('myBusinessEmail'));
        if(!myBusinessEmail) {
          errors.push('My business email is required.');
        } else if(!isValidEmail(myBusinessEmail)) {
          errors.push('My business email must be a valid email address.');
        }
        const myBusinessPhone = normalizeSingleLineText(formData.get('myBusinessPhone'));
        const myBusinessAddress = normalizeMultilineText(formData.get('myBusinessAddress'));
        if(!myBusinessAddress) {
          errors.push('My business mailing address is required.');
        }
        const howToPay = normalizeMultilineText(formData.get('howToPay'));
        const clientBusinessName = normalizeSingleLineText(formData.get('clientBusinessName'));
        if(!clientBusinessName) {
          errors.push('Client business name is required.');
        }
        const clientBusinessAddress = normalizeMultilineText(formData.get('clientBusinessAddress'));
        if(!clientBusinessAddress) {
          errors.push('Client business mailing address is required.');
        }
        const clientBusinessPhone = normalizeSingleLineText(formData.get('clientBusinessPhone'));
        const clientContactName = normalizeSingleLineText(formData.get('clientContactName'));
        const clientContactEmail = normalizeSingleLineText(formData.get('clientContactEmail'));
        if(clientContactEmail && !isValidEmail(clientContactEmail)) {
          errors.push('Client contact email must be a valid email address.');
        }
        const accentColorRaw = (formData.get('accentColor') ?? '').toString().trim();
        const accentColor = isValidHexColor(accentColorRaw) ? accentColorRaw : DEFAULT_ACCENT_COLOR;
        if(accentColorRaw && !isValidHexColor(accentColorRaw)) {
          errors.push('Accent colour must be a valid hex colour.');
        }
        return {
          data: {
            invoiceNumber,
            clientInvoiceNumber,
            hourlyRate,
            taxRatePercent,
            myBusiness: {
              name: myBusinessName,
              email: myBusinessEmail,
              phone: myBusinessPhone,
              address: myBusinessAddress,
            },
            clientBusiness: {
              name: clientBusinessName,
              address: clientBusinessAddress,
              phone: clientBusinessPhone,
            },
            clientContact: {
              name: clientContactName,
              email: clientContactEmail,
            },
            howToPay,
            accentColor,
          },
          errors,
        };
      }

      presentInvoiceErrors(errors) {
        if(!Array.isArray(errors) || errors.length === 0) {
          return;
        }
        const uniqueErrors = [...new Set(errors)];
        const message = `Please correct the following invoice fields:\n ${uniqueErrors.join('\n ')}`;
        presentError(message);
      }

      async loadTemplates() {
        if(this.templates) {
          return this.templates;
        }
        if(!this.templatePromise) {
          this.templatePromise = new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler((templates) => {
                this.templates = templates;
                resolve(this.templates);
              })
              .withFailureHandler((error) => {
                this.templatePromise = null;
                reject(error);
              })
              .client_getInvoiceTemplates();
          });
        }
        return this.templatePromise;
      }

      prepareRows(hourlyRate) {
        if(!this.resultsData) {
          return [];
        }
        return this.resultsData.eventsData
          .slice()
          .sort((a, b) => (new Date(a.start)) - (new Date(b.start)))
          .map((eventData) => this.transformEvent(eventData, hourlyRate));
      }

      transformEvent(eventData, hourlyRate) {
        const title = (eventData.title || '').trim();
        const startDate = new Date(eventData.start);
        const hours = roundToTwo(eventData.hours);
        const safeRate = Number.isFinite(hourlyRate) ? hourlyRate : 0;
        const amountCents = Math.round(hours * safeRate * 100);
        const amount = amountCents / 100;
        const rateText = formatCurrency(safeRate).replace(/\.00$/, '');
        return {
          rawTitle: title,
          truncatedTitle: this.truncateDescription(title),
          dateText: formatInvoiceRowDate(startDate),
          startTimeText: formatInvoiceRowTime(startDate),
          hoursText: formatHours(hours),
          amountText: formatCurrency(amount),
          amountCents,
          rateText,
        };
      }

      truncateDescription(text) {
        if(!text) {
          return '';
        }
        if(!this.measureContext) {
          const MAX_CHARACTERS = 48;
          return text.length <= MAX_CHARACTERS ? text : `${text.slice(0, MAX_CHARACTERS)}...`;
        }
        this.measureContext.font = this.canvasFont;
        if(this.measureContext.measureText(text).width <= INVOICE_DESCRIPTION_MAX_WIDTH) {
          return text;
        }
        let truncated = text;
        const suffix = '...';
        while(truncated.length > 0 && this.measureContext.measureText(truncated + suffix).width > INVOICE_DESCRIPTION_MAX_WIDTH) {
          truncated = truncated.slice(0, -1);
        }
        return truncated.length ? truncated + suffix : suffix;
      }

      buildPages({
        rows,
        templates,
        invoiceNumber,
        clientInvoiceNumber,
        invoiceDate,
        dueDate,
        subtotalText,
        taxText,
        totalText,
        totalHoursString,
        myBusiness,
        clientBusiness,
        clientContact,
        howToPay,
        accentColor,
      }) {
        const pagesConfig = this.partitionRows(rows);
        const totalPages = pagesConfig.length;
        return pagesConfig.map((pageConfig, index) => {
          const isLastPage = (index === totalPages - 1);
          const templateString = isLastPage ? templates.pageWithTotals : templates.pageWithoutTotals;
          const svgElement = this.populatePage({
            templateString,
            rows: pageConfig.rows,
            pageNumber: index + 1,
            totalPages,
            invoiceNumber,
            clientInvoiceNumber,
            invoiceDate,
            dueDate,
            subtotalText,
            taxText,
            totalText,
            includeTotals: isLastPage,
            totalHoursString,
            myBusiness,
            clientBusiness,
            clientContact,
            howToPay,
            accentColor,
          });
          return svgElement;
        });
      }

      partitionRows(rows) {
        if(!Array.isArray(rows) || rows.length === 0) {
          return [];
        }
        const pages = [];
        let cursor = 0;
        while(cursor < rows.length) {
          const remaining = rows.length - cursor;
          if(remaining > MAX_ROWS_PER_STANDARD_PAGE) {
            pages.push({
              rows: rows.slice(cursor, cursor + MAX_ROWS_PER_STANDARD_PAGE),
            });
            cursor += MAX_ROWS_PER_STANDARD_PAGE;
            continue;
          }
          if(remaining > MAX_ROWS_PER_TOTALS_PAGE) {
            // Keep all remaining rows on a standard page, then add an empty totals page.
            pages.push({
              rows: rows.slice(cursor),
            });
            pages.push({
              rows: [],
            });
            cursor = rows.length;
            break;
          }
          pages.push({
            rows: rows.slice(cursor),
          });
          cursor = rows.length;
        }
        return pages;
      }

      populatePage({
        templateString,
        rows,
        pageNumber,
        totalPages,
        invoiceNumber,
        clientInvoiceNumber,
        invoiceDate,
        dueDate,
        subtotalText,
        taxText,
        totalText,
        includeTotals,
        totalHoursString,
        myBusiness,
        clientBusiness,
        clientContact,
        howToPay,
        accentColor,
      }) {
        if(!templateString) {
          throw new Error('#InvoiceBuilderController.populatePage() Missing template string');
        }
        const parser = new DOMParser();
        const doc = parser.parseFromString(templateString, 'image/svg+xml');
        const parserError = doc.querySelector('parsererror');
        if(parserError) {
          throw new Error(`#InvoiceBuilderController.populatePage()
          Failed to parse SVG template. ${parserError.textContent}`);
        }
        const svgElement = doc.documentElement;
        const headersElement = doc.getElementById('Headers') || doc.getElementById('headersContainer');
        const rowsContainer = doc.getElementById('Rows') || doc.getElementById('rowsContainer');
        const hasRows = Array.isArray(rows) && rows.length > 0;
        this.setTextContent(doc, 'pageValue', `Page ${pageNumber} of ${totalPages}`);
        this.setTextContent(doc, 'invoiceNumberValue', invoiceNumber);
        this.setTextContent(doc, 'clientInvoiceNumberContainerValue', clientInvoiceNumber || '');
        const invoiceDateText = formatInvoiceHeaderDate(invoiceDate);
        const dueDateText = formatInvoiceHeaderDate(dueDate);
        this.setTextContent(doc, 'invoiceDataValue', invoiceDateText);
        this.setTextContent(doc, 'dueDataValue', dueDateText);
        this.setTextContent(doc, 'invoiceOfValue', totalText);
        if(includeTotals) {
          this.setTextContent(doc, 'subtotalValue', subtotalText);
          this.setTextContent(doc, 'totalValue', totalText);
          this.setTextContent(doc, 'taxValue', taxText);
          if(typeof totalHoursString === 'string') {
            this.setTextContent(doc, 'totalHoursValue', totalHoursString);
          }
        }
        if(myBusiness) {
          this.setTextContent(doc, 'myNameValue', myBusiness.name ?? '');
          this.setTextContent(doc, 'myEmailValue', myBusiness.email ?? '');
          this.setTextContent(doc, 'myPhoneNumberValue', myBusiness.phone ?? '');
          this.setTextContent(doc, 'myAddressValue', myBusiness.address ?? '');
        }
        if(typeof howToPay === 'string') {
          this.setTextContent(doc, 'howToPayValue', howToPay);
        }
        if(clientBusiness) {
          const billedToText = buildMultilineValue([
            clientBusiness.name,
            clientBusiness.address,
            clientBusiness.phone,
          ]);
          this.setTextContent(doc, 'billedToValue', billedToText);
        }
        if(clientContact) {
          const contactText = buildMultilineValue([
            clientContact.name,
            clientContact.email,
          ]);
          this.setTextContent(doc, 'contactPersonValue', contactText);
        }
        this.applyAccentColor(doc, accentColor);
        if(includeTotals && !hasRows) {
          this.hideSvgElement(headersElement);
          this.hideSvgElement(rowsContainer);
        } else {
          this.populateRows(doc, rows);
        }
        this.prefixIds(svgElement, `invoicePage${pageNumber}`);
        return document.importNode(svgElement, true);
      }

      populateRows(doc, rows) {
        const rowsContainer = doc.getElementById('Rows') || doc.getElementById('rowsContainer');
        if(!rowsContainer) {
          throw new Error('#InvoiceBuilderController.populateRows() Missing rows container in SVG template');
        }
        const lightTemplate = rowsContainer.querySelector('#rowContainer_light');
        const darkTemplate = rowsContainer.querySelector('#rowContainer__dark');
        if(!lightTemplate || !darkTemplate) {
          throw new Error('#InvoiceBuilderController.populateRows() Missing row templates in SVG');
        }
        const lightTemplateClone = lightTemplate.cloneNode(true);
        const darkTemplateClone = darkTemplate.cloneNode(true);
        rowsContainer.replaceChildren();
        rows.forEach((row, index) => {
          const template = (index % 2 === 0 ? lightTemplateClone : darkTemplateClone).cloneNode(true);
          const baselineY = ROW_BASELINE_START_Y + (index * ROW_VERTICAL_SPACING);
          this.setRowText(template, 'dateValue', row.dateText, baselineY);
          this.setRowText(template, 'descriptionValue', row.truncatedTitle, baselineY);
          this.setRowText(template, 'hoursValue', row.hoursText, baselineY);
          this.setRowText(template, 'startTimeValue', row.startTimeText, baselineY);
          this.setRowText(template, 'rateValue', row.rateText, baselineY);
          this.setRowText(template, 'amountValue', row.amountText, baselineY);
          this.adjustRowBackground(template, baselineY);
          rowsContainer.appendChild(template);
        });
      }

      applyAccentColor(doc, accentColor) {
        const color = isValidHexColor(accentColor) ? accentColor : DEFAULT_ACCENT_COLOR;
        const accentTargets = ['invoiceOfValue', 'myNameValue', 'totalValue', 'Total'];
        accentTargets.forEach((id) => {
          const element = doc.getElementById(id);
          this.setFillColor(element, color);
        });
      }

      setFillColor(element, color) {
        if(!element || !color) {
          return;
        }
        element.setAttribute('fill', color);
        const tspans = element.querySelectorAll('tspan');
        if(tspans.length > 0) {
          tspans.forEach((span) => span.setAttribute('fill', color));
        }
      }

      setRowText(rowGroup, idPrefix, value, baselineY) {
        const element = rowGroup.querySelector(`[id^="${idPrefix}"]`);
        this.setElementText(element, value);
        this.setElementPosition(element, baselineY);
      }

      setTextContent(doc, id, value) {
        const element = doc.getElementById(id);
        this.setElementText(element, value);
      }

      prefixIds(rootElement, prefix) {
        const elementsWithId = rootElement.querySelectorAll('[id]');
        elementsWithId.forEach((element) => {
          element.id = `${prefix}_${element.id}`;
        });
      }

      setElementText(element, value) {
        if(!element) {
          return;
        }
        const stringValue = (value ?? '').toString();
        const lines = stringValue.split('\n');
        const isMultiLine = lines.length > 1;
        const namespace = element.ownerDocument?.documentElement?.namespaceURI || 'http://www.w3.org/2000/svg';
        let tspans = element.tagName.toLowerCase() === 'tspan'
          ? [element]
          : Array.from(element.querySelectorAll('tspan'));
        const getSpanYValue = (span) => {
          if(!span) {
            return Number.NaN;
          }
          const yAttr = span.getAttribute('y');
          return typeof yAttr === 'string' && yAttr.length > 0 ? parseFloat(yAttr) : Number.NaN;
        };
        const computeLineSpacing = (spans) => {
          if(!Array.isArray(spans) || spans.length < 2) {
            return ROW_MULTILINE_LINE_HEIGHT;
          }
          const baseY = getSpanYValue(spans[0]);
          for(let index = 1; index < spans.length; index += 1) {
            const currentY = getSpanYValue(spans[index]);
            if(!Number.isNaN(baseY) && !Number.isNaN(currentY)) {
              const delta = currentY - baseY;
              if(Number.isFinite(delta) && delta !== 0) {
                return delta;
              }
            }
          }
          return ROW_MULTILINE_LINE_HEIGHT;
        };

        if(tspans.length === 0 && isMultiLine) {
          const newTspan = element.ownerDocument?.createElementNS(namespace, 'tspan') ?? document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
          if(element.hasAttribute('x')) {
            newTspan.setAttribute('x', element.getAttribute('x'));
          }
          if(element.hasAttribute('y')) {
            newTspan.setAttribute('y', element.getAttribute('y'));
          }
          element.textContent = '';
          element.appendChild(newTspan);
          tspans = [newTspan];
        }

        if(tspans.length > 0) {
          let lineSpacing = computeLineSpacing(tspans);
          if(!Number.isFinite(lineSpacing) || lineSpacing === 0) {
            lineSpacing = ROW_MULTILINE_LINE_HEIGHT;
          }
          const templateSpan = tspans[0];
          if(isMultiLine) {
            while(tspans.length < lines.length) {
              const clone = templateSpan.cloneNode(true);
              clone.textContent = '';
               const previousSpan = tspans[tspans.length - 1];
               const previousY = getSpanYValue(previousSpan);
               if(!Number.isNaN(previousY)) {
                 clone.setAttribute('y', (previousY + lineSpacing).toFixed(3));
               }
              element.appendChild(clone);
              tspans.push(clone);
            }
          }
          while(tspans.length > lines.length) {
            const removed = tspans.pop();
            if(removed?.parentNode) {
              removed.parentNode.removeChild(removed);
            }
          }
          tspans.forEach((span, index) => {
            span.textContent = lines[index] ?? '';
          });
        } else {
          element.textContent = stringValue;
        }
        const updatedTspans = element.tagName.toLowerCase() === 'tspan'
          ? [element]
          : Array.from(element.querySelectorAll('tspan'));
        this.applyRightAlignedFormatting(element, updatedTspans);
      }

      setElementPosition(element, baselineY) {
        if(!element || typeof baselineY !== 'number' || Number.isNaN(baselineY)) {
          return;
        }
        const tspans = element.tagName.toLowerCase() === 'tspan'
          ? [element]
          : Array.from(element.querySelectorAll('tspan'));
        if(tspans.length > 0) {
          tspans.forEach((span, index) => {
            const yValue = baselineY + (index * ROW_MULTILINE_LINE_HEIGHT);
            span.setAttribute('y', yValue.toFixed(3));
          });
        } else if(element.hasAttribute('y')) {
          element.setAttribute('y', baselineY.toFixed(3));
        }
      }

      adjustRowBackground(rowGroup, baselineY) {
        const backgroundRect = rowGroup.querySelector('rect');
        if(!backgroundRect || typeof baselineY !== 'number' || Number.isNaN(baselineY)) {
          return;
        }
        const transform = backgroundRect.getAttribute('transform');
        const match = transform?.match(/translate\(\s*([-\d.]+)[ ,]+([-\d.]+)\s*\)/);
        if(!match) {
          return;
        }
        const x = parseFloat(match[1]);
        const newY = baselineY - DARK_ROW_RECT_VERTICAL_OFFSET;
        backgroundRect.setAttribute('transform', `translate(${x} ${newY.toFixed(3)})`);
      }

      renderPages(pages) {
        if(!this.outputElement) {
          return;
        }
        this.outputElement.innerHTML = '';
        pages.forEach((page) => {
          this.outputElement.appendChild(page);
        });
        this.setDownloadButtonState(pages && pages.length > 0);
      }

      setDownloadButtonState(isEnabled) {
        const buttons = [this.downloadButton, this.downloadSvgButton].filter(Boolean);
        if(buttons.length === 0) {
          return;
        }
        const hasOutput = !!this.outputElement && this.outputElement.childElementCount > 0;
        buttons.forEach((button) => {
          if(isEnabled) {
            button.disabled = false;
            button.classList.remove('display-none');
          } else {
            button.disabled = true;
            if(!hasOutput) {
              button.classList.add('display-none');
            }
          }
        });
      }

      async handleDownloadClick() {
        if(!this.outputElement || this.outputElement.childElementCount === 0) {
          return;
        }
        if(this.downloadButton) {
          this.downloadButton.disabled = true;
        }
        if(this.downloadSvgButton) {
          this.downloadSvgButton.disabled = true;
        }
        try {
          await this.downloadInvoicePdf();
        } catch (error) {
          console.error('#InvoiceBuilderController.downloadInvoicePdf()', error);
          presentError('Unable to download the invoice PDF. Please try again.');
        } finally {
          this.setDownloadButtonState(this.outputElement?.childElementCount > 0);
        }
      }

      async handleSvgDownloadClick() {
        if(!this.outputElement || this.outputElement.childElementCount === 0) {
          return;
        }
        if(this.downloadSvgButton) {
          this.downloadSvgButton.disabled = true;
        }
        if(this.downloadButton) {
          this.downloadButton.disabled = true;
        }
        try {
          await this.downloadInvoiceSvg();
        } catch (error) {
          console.error('#InvoiceBuilderController.downloadInvoiceSvg()', error);
          presentError('Unable to download the invoice SVG files. Please try again.');
        } finally {
          this.setDownloadButtonState(this.outputElement?.childElementCount > 0);
        }
      }

      async downloadInvoiceSvg() {
        const svgElements = Array.from(this.outputElement?.querySelectorAll('svg') || []);
        if(svgElements.length === 0) {
          throw new Error('No invoice pages available to export.');
        }
        const serializer = new XMLSerializer();
        const totalPages = svgElements.length;
        svgElements.forEach((svgElement, index) => {
          const clone = svgElement.cloneNode(true);
          this.prepareSvgForDownload(clone);
          this.revertRightAlignedTextForSvgExport(clone);
          const serialized = serializer.serializeToString(clone);
          const svgContent = `<?xml version="1.0" encoding="UTF-8"?>\n${serialized}`;
          const filename = this.buildSvgFilename(index + 1, totalPages);
          this.triggerSvgDownload(svgContent, filename);
        });
      }

      prepareSvgForDownload(svgElement) {
        if(!svgElement || typeof svgElement.setAttribute !== 'function') {
          return;
        }
        svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
        svgElement.setAttribute('width', '595');
        svgElement.setAttribute('height', '842');
        if(!svgElement.getAttribute('viewBox')) {
          svgElement.setAttribute('viewBox', '0 0 595 842');
        }
      }

      revertRightAlignedTextForSvgExport(svgElement) {
        if(!svgElement || typeof svgElement.querySelectorAll !== 'function') {
          return;
        }
        const parseStoredOriginalX = (node) => {
          if(!node) {
            return Number.NaN;
          }
          const datasetValue = node.dataset?.invoiceOriginalX;
          if(typeof datasetValue === 'string' && datasetValue.length > 0) {
            const parsed = parseFloat(datasetValue);
            if(Number.isFinite(parsed)) {
              return parsed;
            }
          }
          const attrValue = node.getAttribute('data-invoice-original-x');
          if(typeof attrValue === 'string' && attrValue.length > 0) {
            const parsed = parseFloat(attrValue);
            if(Number.isFinite(parsed)) {
              return parsed;
            }
          }
          return Number.NaN;
        };
        const textElements = svgElement.querySelectorAll('text[data-invoice-original-x]');
        textElements.forEach((textElement) => {
          const originalX = parseStoredOriginalX(textElement);
          if(Number.isFinite(originalX)) {
            textElement.setAttribute('x', originalX.toFixed(3));
          } else if(textElement.hasAttribute('x')) {
            const currentX = textElement.getAttribute('x');
            if(typeof currentX === 'string' && currentX.length > 0) {
              textElement.setAttribute('x', parseFloat(currentX).toFixed(3));
            }
          }
          this.clearTextAnchorStyle(textElement);
          textElement.removeAttribute('data-invoice-original-x');
          if(textElement.dataset) {
            delete textElement.dataset.invoiceOriginalX;
          }
        });
        const tspanElements = svgElement.querySelectorAll('tspan[data-invoice-original-x]');
        tspanElements.forEach((span) => {
          const originalX = parseStoredOriginalX(span);
          if(Number.isFinite(originalX)) {
            span.setAttribute('x', originalX.toFixed(3));
          } else if(span.hasAttribute('x')) {
            const currentX = span.getAttribute('x');
            if(typeof currentX === 'string' && currentX.length > 0) {
              span.setAttribute('x', parseFloat(currentX).toFixed(3));
            }
          }
          this.clearTextAnchorStyle(span);
          const parentText = typeof span.closest === 'function' ? span.closest('text') : null;
          if(parentText && !parentText.hasAttribute('data-invoice-original-x')) {
            const parentX = parentText.getAttribute('x');
            if(!parentX && Number.isFinite(originalX)) {
              parentText.setAttribute('x', originalX.toFixed(3));
            }
            this.clearTextAnchorStyle(parentText);
          }
          span.removeAttribute('data-invoice-original-x');
          if(span.dataset) {
            delete span.dataset.invoiceOriginalX;
          }
        });
      }

      triggerSvgDownload(svgContent, filename) {
        const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        const cleanup = () => {
          if(link.parentNode) {
            link.parentNode.removeChild(link);
          }
          URL.revokeObjectURL(url);
        };
        if(typeof requestAnimationFrame === 'function') {
          requestAnimationFrame(cleanup);
        } else {
          setTimeout(cleanup, 0);
        }
      }

      ensurePdfLibraries() {
        const jsPdfNamespace = window.jspdf || window.jsPDF || window.jspPDF || {};
        const jsPDFConstructor = jsPdfNamespace.jsPDF || window.jsPDF || window.jspPDF;
        const svg2pdfNamespace = window.svg2pdf || window.SVG2PDF || window.svg2pdfjs || {};
        const svg2pdfCandidates = [
          svg2pdfNamespace,
          svg2pdfNamespace.default,
          svg2pdfNamespace.svg2pdf,
          svg2pdfNamespace.SVG2PDF,
          svg2pdfNamespace.svg2pdfjs,
          window.svg2pdf,
          window.svg2pdf?.svg2pdf,
          window.svg2pdf?.default,
          window.SVG2PDF,
          window.svg2pdfjs,
        ];
        let svg2pdfFunction = svg2pdfCandidates.find((candidate) => typeof candidate === 'function');
        if(!svg2pdfFunction && svg2pdfNamespace && typeof svg2pdfNamespace === 'object') {
          const nestedCandidates = Object.values(svg2pdfNamespace)
            .flatMap((value) => (typeof value === 'object' ? [value, value?.default, value?.svg2pdf, value?.SVG2PDF] : [value]));
          svg2pdfFunction = nestedCandidates.find((value) => typeof value === 'function') ?? svg2pdfFunction;
        }
        if(typeof jsPDFConstructor !== 'function' || typeof svg2pdfFunction !== 'function') {
          const details = JSON.stringify({
            jspdfKeys: Object.keys(window).filter((key) => key.toLowerCase().includes('jspdf') || key.toLowerCase() === 'jspdf'),
            svg2pdfKeys: Object.keys(window).filter((key) => key.toLowerCase().includes('svg2pdf')),
            svg2pdfNamespaceKeys: Object.keys(svg2pdfNamespace || {}),
            typeofJsPdfConstructor: typeof jsPDFConstructor,
            typeofSvg2pdf: typeof svg2pdfFunction,
            svg2pdfNamespaceType: typeof svg2pdfNamespace,
            svg2pdfNamespaceEntries: Object.entries(svg2pdfNamespace || {}).map(([key, value]) => `${key}:${typeof value}`),
          }, null, 2);
          throw new Error(`PDF libraries are not loaded. Debug: ${details}`);
        }
        return { jsPDFConstructor, svg2pdf: svg2pdfFunction };
      }

      async downloadInvoicePdf() {
        const svgElements = Array.from(this.outputElement?.querySelectorAll('svg') || []);
        if(svgElements.length === 0) {
          throw new Error('No invoice pages available to export.');
        }
        console.log('#InvoiceBuilderController.downloadInvoicePdf() start');
        const { jsPDFConstructor, svg2pdf } = this.ensurePdfLibraries();
        const pageWidth = 595;
        const pageHeight = 842;
        const doc = new jsPDFConstructor({
          unit: 'pt',
          format: [pageWidth, pageHeight],
          orientation: 'portrait',
          hotfixes: ['px_scaling'],
        });
        const defaultFontName = this.registerPdfFonts(doc);
        const defaultFont = this.applyFontHotfix(doc, defaultFontName);
        console.log('#InvoiceBuilderController.downloadInvoicePdf() svgElements', svgElements.length);
        for(const [index, svgElement] of svgElements.entries()) {
          console.log(`#InvoiceBuilderController.downloadInvoicePdf() processing page ${index + 1}`);
          if(index > 0) {
            doc.addPage([pageWidth, pageHeight], 'portrait');
            doc.setPage(index + 1);
          }
          const clonedSvg = svgElement.cloneNode(true);
          clonedSvg.setAttribute('width', `${pageWidth}`);
          clonedSvg.setAttribute('height', `${pageHeight}`);
          this.normalizeSvgFonts(clonedSvg, defaultFont);
          const options = {
            x: 0,
            y: 0,
            width: pageWidth,
            height: pageHeight,
            useCSS: true,
            assumePt: true,
          };
          console.log('#InvoiceBuilderController.downloadInvoicePdf() svg2pdf options', options);
          try {
            await Promise.resolve(svg2pdf(clonedSvg, doc, options));
            console.log(`#InvoiceBuilderController.downloadInvoicePdf() svg2pdf finished page ${index + 1}`);
          } catch (error) {
            console.error(`#InvoiceBuilderController.downloadInvoicePdf() svg2pdf error on page ${index + 1}`, error);
            throw error;
          }
        }
        console.log('#InvoiceBuilderController.downloadInvoicePdf() saving PDF');
        doc.save(this.buildPdfFilename());
        console.log('#InvoiceBuilderController.downloadInvoicePdf() complete');
      }

      buildSvgFilename(pageNumber, totalPages) {
        const filenameBase = this.getInvoiceFilenameBase();
        if(totalPages > 1) {
          const pageSuffix = String(pageNumber).padStart(2, '0');
          return `${filenameBase}-page-${pageSuffix}.svg`;
        }
        return `${filenameBase}.svg`;
      }

      buildPdfFilename() {
        const filenameBase = this.getInvoiceFilenameBase();
        return `${filenameBase}.pdf`;
      }

      getInvoiceFilenameBase() {
        const businessName = this.sanitizeFilenameComponent(this.lastInvoiceMetadata?.myBusinessName || '');
        const invoiceNumber = this.sanitizeFilenameComponent(this.lastInvoiceMetadata?.invoiceNumber || 'invoice');
        const clientInvoiceNumber = this.sanitizeFilenameComponent(this.lastInvoiceMetadata?.clientInvoiceNumber || '');
        const businessSegment = businessName.length > 0 ? businessName : 'invoice';
        const invoiceSegment = invoiceNumber.length > 0 ? invoiceNumber : 'invoice';
        const combined = clientInvoiceNumber.length > 0
          ? `${businessSegment} Invoice ${clientInvoiceNumber} } ${invoiceSegment}`
          : `${businessSegment} Invoice ${invoiceSegment}`;
        return combined.replace(/\s{2,}/g, ' ').trim();
      }

      sanitizeFilenameComponent(value) {
        if(value == null) {
          return '';
        }
        const stringValue = value.toString().replace(/[\u0000-\u001F\u007F]/g, '');
        const collapsedWhitespace = stringValue.replace(/\s+/g, ' ').trim();
        const sanitized = collapsedWhitespace.replace(/[<>:"/\\|?*]/g, '');
        return sanitized;
      }

      registerPdfFonts(doc) {
        try {
          const fontList = doc.getFontList?.() || {};
          if(!fontList[DEFAULT_PDF_FONT]) {
            if(FONT_UBUNTU_REGULAR_BASE64 && FONT_UBUNTU_BOLD_BASE64) {
              doc.addFileToVFS(`${DEFAULT_PDF_FONT}-Regular.ttf`, FONT_UBUNTU_REGULAR_BASE64);
              doc.addFont(`${DEFAULT_PDF_FONT}-Regular.ttf`, DEFAULT_PDF_FONT, 'normal');
              doc.addFileToVFS(`${DEFAULT_PDF_FONT}-Bold.ttf`, FONT_UBUNTU_BOLD_BASE64);
              doc.addFont(`${DEFAULT_PDF_FONT}-Bold.ttf`, DEFAULT_PDF_FONT, 'bold');
              console.log(`#registerPdfFonts() Registered ${DEFAULT_PDF_FONT} fonts`);
            }
          }
          return DEFAULT_PDF_FONT;
        } catch (error) {
          console.warn('#registerPdfFonts() failed, falling back to Helvetica', error);
          return 'Helvetica';
        }
      }

      applyFontHotfix(doc, preferredFont) {
        let defaultFont = preferredFont || 'Helvetica';
        try {
          doc.getFont(defaultFont.toLowerCase(), 'normal');
        } catch (error) {
          const fontList = doc.getFontList?.() || {};
          const firstFontKey = Object.keys(fontList)[0];
          defaultFont = firstFontKey ?? 'Helvetica';
        }
        doc.setFont(defaultFont, 'normal');
        return defaultFont;
      }

      normalizeSvgFonts(svgRoot, defaultFont) {
        if(!svgRoot) {
          return;
        }
        console.log('#InvoiceBuilderController.normalizeSvgFonts()', { defaultFont });
        const elementsWithFontFamily = svgRoot.querySelectorAll('[font-family]');
        elementsWithFontFamily.forEach((element) => {
          element.setAttribute('font-family', defaultFont);
        });
        const elementsWithFontWeight = svgRoot.querySelectorAll('[font-weight]');
        elementsWithFontWeight.forEach((element) => {
          const weight = element.getAttribute('font-weight');
          const normalized = this.getNormalizedFontWeight(weight);
          if(normalized) {
            element.setAttribute('font-weight', normalized);
          }
        });
        const styledElements = svgRoot.querySelectorAll('[style], text');
        styledElements.forEach((element) => {
          const style = element.getAttribute('style');
          if(!style) return;
          const declarations = style.split(';').map((declaration) => declaration.trim()).filter(Boolean);
          let hasFontFamily = false;
          let hasFontWeight = false;
          const updatedDeclarations = declarations.map((declaration) => {
            const [property, value] = declaration.split(':').map((part) => part.trim());
            if(!property) return null;
            if(property.toLowerCase() === 'font-family') {
              hasFontFamily = true;
              return `font-family: ${defaultFont}`;
            }
            if(property.toLowerCase() === 'font-weight') {
              hasFontWeight = true;
              return `font-weight: ${this.getNormalizedFontWeight(value) ?? '400'}`;
            }
            return `${property}: ${value}`;
          }).filter(Boolean);
          if(!hasFontFamily) {
            updatedDeclarations.push(`font-family: ${defaultFont}`);
          }
          if(!hasFontWeight) {
            updatedDeclarations.push('font-weight: 400');
          }
          element.setAttribute('style', updatedDeclarations.join('; '));
        });
      }

      getNormalizedFontWeight(weightValue) {
        if(!weightValue) {
          return 'normal';
        }
        const normalizedLower = weightValue.toString().trim().toLowerCase();
        if(normalizedLower === 'bold' || normalizedLower === '700') {
          return 'bold';
        }
        if(normalizedLower === 'normal' || normalizedLower === '400') {
          return 'normal';
        }
        const numericValue = parseInt(normalizedLower, 10);
        if(Number.isFinite(numericValue)) {
          return numericValue >= 600 ? 'bold' : 'normal';
        }
        return 'normal';
      }

      applyRightAlignedFormatting(element, cachedTspans) {
        if(!element) {
          return;
        }
        const elementId = (element.id || '').toLowerCase();
        const shouldAlign = RIGHT_ALIGNED_IDS.some((idFragment) => elementId.includes(idFragment));
        if(!shouldAlign) {
          return;
        }
        const targetTextElement = element?.tagName?.toLowerCase() === 'text'
          ? element
          : typeof element?.closest === 'function'
            ? element.closest('text')
            : null;
        if(targetTextElement && typeof targetTextElement.setAttribute === 'function') {
          const existingStored = targetTextElement.dataset?.invoiceOriginalX;
          if(!existingStored) {
            const textOriginalXAttr = targetTextElement.getAttribute('x');
            const parsed = typeof textOriginalXAttr === 'string' && textOriginalXAttr.length > 0
              ? parseFloat(textOriginalXAttr)
              : Number.NaN;
            if(Number.isFinite(parsed)) {
              targetTextElement.dataset.invoiceOriginalX = parsed;
            }
          }
          targetTextElement.setAttribute('text-anchor', 'end');
          this.ensureTextAnchorStyle(targetTextElement);
        }
        const candidateSpans = cachedTspans && cachedTspans.length > 0
          ? cachedTspans
          : element.tagName.toLowerCase() === 'tspan'
            ? [element]
            : Array.from(element.querySelectorAll('tspan'));
        const targets = candidateSpans.length > 0 ? candidateSpans : [element];
        targets.forEach((span) => {
          span.setAttribute('text-anchor', 'end');
          this.ensureTextAnchorStyle(span);
          const existingXAttr = span.getAttribute('x') ?? element.getAttribute('x');
          const storedOriginal = span.dataset.invoiceOriginalX;
          const originalX = Number.isFinite(Number(storedOriginal))
            ? Number(storedOriginal)
            : Number(existingXAttr);
          if(Number.isFinite(originalX)) {
            span.dataset.invoiceOriginalX = originalX;
            const targetX = this.computeRightAlignedTargetX(elementId, originalX);
            span.setAttribute('x', targetX.toFixed(3));
            if(targetTextElement && typeof targetTextElement.setAttribute === 'function') {
              if(!targetTextElement.dataset?.invoiceOriginalX) {
                targetTextElement.dataset.invoiceOriginalX = originalX;
              }
              targetTextElement.setAttribute('x', targetX.toFixed(3));
            }
          }
        });
      }

      hideSvgElement(element) {
        if(!element) {
          return;
        }
        element.setAttribute('display', 'none');
      }

      computeRightAlignedTargetX(elementId, originalX) {
        let targetX = originalX;
        if(elementId.includes('amountvalue') || elementId.includes('ratevalue')) {
          targetX = Math.min(originalX, ROW_RIGHT_BOUNDARY_X - ROW_RIGHT_PADDING);
        } else if(
          elementId.includes('invoiceofvalue')
          || elementId.includes('totalhoursvalue')
          || elementId.includes('subtotalvalue')
          || elementId.includes('totalvalue')
          || elementId.includes('taxvalue')
        ) {
          targetX = Math.min(originalX, SUMMARY_RIGHT_BOUNDARY_X - SUMMARY_RIGHT_PADDING);
        }
        return targetX + this.getRightAlignmentOffset(elementId);
      }

      getRightAlignmentOffset(elementId) {
        if(!elementId) {
          return 0;
        }
        const lowerId = elementId.toLowerCase();
        const override = RIGHT_ALIGNMENT_X_OFFSET_OVERRIDES.find(({ idFragment }) => lowerId.includes(idFragment));
        return override?.offset ?? 0;
      }

      ensureTextAnchorStyle(node) {
        if(!node || typeof node.getAttribute !== 'function' || typeof node.setAttribute !== 'function') {
          return;
        }
        const existingStyle = node.getAttribute('style') || '';
        const anchorRegex = /(^|;)\s*text-anchor\s*:/i;
        if(anchorRegex.test(existingStyle)) {
          const updatedStyle = existingStyle.replace(/text-anchor\s*:[^;]*/gi, 'text-anchor: end');
          node.setAttribute('style', updatedStyle);
        } else {
          const normalizedStyle = existingStyle.trim().replace(/;$/, '');
          const suffix = normalizedStyle.length > 0 ? `${normalizedStyle}; text-anchor: end` : 'text-anchor: end';
          node.setAttribute('style', suffix);
        }
      }

      clearTextAnchorStyle(node) {
        if(!node || typeof node.removeAttribute !== 'function' || typeof node.getAttribute !== 'function') {
          return;
        }
        node.removeAttribute('text-anchor');
        const style = node.getAttribute('style');
        if(style) {
          const filtered = style
            .split(';')
            .map((declaration) => declaration.trim())
            .filter((declaration) => declaration.length > 0 && !declaration.toLowerCase().startsWith('text-anchor'));
          if(filtered.length > 0) {
            node.setAttribute('style', filtered.join('; '));
          } else {
            node.removeAttribute('style');
          }
        }
      }
    }

    _invoiceBuilderController = new InvoiceBuilderController();
  </script>
</body>
